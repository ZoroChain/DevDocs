NEO 主链 与外部如何安全的通讯

因为NEO 链不具备向外传送信息的功能（作为一个底层公链系统，也不该有）

所以我们需要设计NEO主链与外部安全通讯的机制。

因为NEO链不能主动向外传递信息，那就只能让外部系统来取了。

外部系统可以取到Neo链上的每一笔交易并验证他们。

这就带来了第一步的安全性。

但是仅靠交易本身，不足以携带数据。就算我们反编译交易，这不难，可是无法知道交易执行的结果。

所以我们不依赖交易本身，而是依赖交易的notify 或者叫application log来携带数据。

外部系统对NEO链进行持续的观察，当发现特定的 application
log时，数据就由NEO链传递到了外部系统。

这个过程因为依托NEO链，并且可以验证，是安全的传递过程。因为NEO链的交易都需要私钥签名，智能合约执行过程也可以自我验证保护notify的安全输出。

反过来，如何从外部系统将数据安全的带进NEO链。外部系统自然可以发起任意的NEO交易，我们希望特定外部系统送进NEO系统的交易是难以伪造的，仅仅用“用户的私钥”签名，是不足够的。所以一个简单的办法，就是为每个外部系统保留一个私钥，NEO侧的智能合约内部则保留公钥，限制外部系统使用的功能，必须由此外部系统保留私钥签名，再加上用户签名。这个就比较安全了。

我们由此已经将基本的双向通讯机制设计清楚

1.  ZoroChain 侧有一个自己的私钥，用于向NEO链的对应智能合约发送数据

2.  ZoroChain 监控Neo链的特定Notify取得信息

3.  ZoroChain 向Neo链发送具备专用私钥签名的交易，用于向Neo链发送数据

我们更进一步设计一个rpc机制

1.由neo端的交易 notify携带信息发起，该交易称为A。

2.ZoroChain捕获到这个信息，就在rootchain上发起一笔对应的交易，用A作为该交易的ID。

足够的记账节点捕获到该信息，该信息才能上链（这需要额外的机制，不在此处赘述）。

3.该交易执行完毕之后，ZoroChain向NEO对应的智能合约发起一笔交易，通知这次调用的返回结果，该交易一样留下独特的Notify记号。交易在记账节点执行，每个记账节点都会尝试向NEO发起这笔交易（是同一笔交易）

1.  ZoroChain 捕获到交易A 对应的 返回结果 notify
    后，在rootchain上发起一笔对应的调用完成交易

这个过程可以记为 Rpccall_zoro(txid,state,“xxx”,[]);

对于NEO端来说，他会看到两笔invoke交易，一笔用于向zorochain传递参数，一笔得到zorochain的执行结果。

对于ZoroChain端来说，他也会看到两笔交易，一笔传递参数，一笔显示结果

Zoro链Root 和 App的通讯无需这么麻烦，因为我们可以控制

每一条App链的进程内同时都跑着root链.我们可以在app链的智能合约内，直接读取root链上的交易数据。而写入，我们则往root链上发交易即可
