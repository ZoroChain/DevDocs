# NEO中的数据见证人
---
### 见证人的作用
* 检验一个数据是否被篡改过
* 区块链的数据在P2P网络中传播，过程中需要防止有节点篡改数据

### 见证人的工作原理
* 采用公私钥加密的原理，用私钥对原文进行加密，得到的密文可以用公钥解密，解密后的数据应该和原文相同

### NEO中的数据见证人
* 区块数据和交易数据都需要见证人
* 交易数据的见证人
    * 我们知道在发起一个交易时，需要先拼装交易数据，具体来说就是要构造Transaction对象，并填入对应的UTXO数据和脚本数据
    * 为了防止交易数据被篡改，该交易的发起人在拼装交易数据的过程中，会附带上一段可以用来验证交易数据是否被篡改过的数据
    * 这部分数据里包括了用私钥加密后的交易数据，以及可以用来解密的对应公钥，我们把私钥的所有者称为“见证人”
    * 这部分数据被当做一个虚拟机的指令，在验证交易时执行，进行数据验证
    * 如果该交易里有合约脚本，可以在合约脚本里使用`CheckWitness`来检查该交易是否特定账户发起的
    * 每个交易可以有多个“见证人”
* 区块数据的见证人
    * 在共识过程中，议长会先广播签名数据（用私钥加密后的区块头），以及将要出块的所有交易的Hash
    * 议员在收到议长发出的数据包，并且验证了所有将要出块的交易后，也会广播自己的签名数据（用私钥加密后的区块头）
    * 当某个共识节点收到的签名数据达到了通过决议的最小数量时，则认为共识通过，开始正式创建区块数据
    * 在创建新的区块数据时，会将收到的这些签名数据和对应公钥作为这个区块的“见证人”

### NEO中对一笔UTXO交易进行签名验证的原理
* 创建账户时，会用该账户的公钥生成一段验证签名的虚拟机字节码，并将这段字节码的Hash作为该账户的地址
* 也就是说，账户的地址就是用来验证本账户签名的脚本Hash，但这个脚本Hash因为并没有当做合约来发布，所以不能通过AppCall来调用
* 当发起一个从某个账户转出货币的交易，在验证该交易时需要检查是否有这个账户的签名，以此判断该交易是否合法
* 交易发起人在拼装交易体时，需要在交易的见证人数据区里填入转出账户的公钥和私钥加密后的数据
* 在检查交易见证人签名的代码里，会根据本次交易的货币来源账户，得到该账户的验签脚本的Hash，并和见证人里的验签脚本的Hash做对比
* 如果对比一致，表示交易的见证人签名是本人的真实签名

### NEO中对一个新区块进行签名验证的原理
* 检查一个新区块的签名，其实就是检查生成这个区块的所有共识节点的签名
* 当某个共识节点收到的新区块头的签名数据达到了通过决议的最小数量时，认为达成了共识，开始正式创建区块数据
* 在创建新区块时，会把自己和其他共识节点的对区块头的签名数据（公钥和对应的加密数据)，合并成一个检查多重签名的脚本字节码，填入见证人数据区里，
* 同时这个区块头里，会记录检查多签的脚本Hash（`BlockBase.NextConsensus`）
* 在检查区块的见证人签名时，会把见证人里的检查多签的脚本做Hash，与区块头里记录的Hash做对比
* 如果对比一致，表示该区块的见证人签名是有效的